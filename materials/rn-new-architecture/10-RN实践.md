# RN 实践

1. 刚刚开始学习的时候，不要一头扎进技术的细节中去学习，应该拿起 React Native 的知识地图先看看，知道自己学习的方向并给自己树立一个学习目标。

**这样的思路对其他技术学习也有借鉴意义。**

2. **实践是检验整理的唯一标准。**

## 简易电商首页

### 项目结构

1. **搭建页面讲究的是代码未动构思先行。**

动手开发，一般会从三个技术维度进行思考，**项目维度、页面维度和单个组件维度，**主要围绕技术选型、可行性、可扩展性、可维护性这些方向进行。

2. 遇到大的需求，**建议先写技术文档，内容包括核心技术选型、组件拆分方式、组件之间的关系、状态的数据结构和流程图，等等。**

写文档的过程也就是把模糊的构思变成清晰的文字的过程，在这个过程中，我会找出一些以前没有思考到的要点，把风险提前暴露出来，同时写文档也能帮我把设计思路变得更有条理一些。

3. 在项目维度上，更值得和你探讨的问题是：**项目目录应该如何设计，才能支撑后续项目变大的可扩展性和可维护性？**

```md
.
├── api
│ └── homeAPI.tsx
├── components
│ ├── Grid
│ └── RecyclerListView
├── utils
├── features
│ ├── Icons
│ ├── List
│ ├── TopBar
│ └── WaterFallCard
└── index.tsx
```

- api：后端约定好的接口地址不容易变，因此我把请求后端接口的函数都放到了 homeAPI.tsx 的文件中了；
- components：开发页面中能够沉淀下来，后续可能复用的组件，我会放到 components 文件夹中。比如，金刚位中 2 \* 5 的图标，它的布局方式就是网格布局，那就可以抽离一个通用的网格布局组件 Grid；
- utils：通用工具函数；
- features：业务组件和其后端接口数据的处理逻辑部分，它们是最容易变动的，而且关联性很强，因此我把它们看作一个功能，有时候代码行数不多我也会偷懒不拆，直接把这组件和组件的后端数据处理逻辑放到同一个文件中。按功能 feature 拆分而不是按组件本身进行拆分的思路，我是从 Redux 的最佳实践中学来的。“Structure Files as Feature Folders with Single-File Logic”，相同 feature 的文件，都放在同一个文件夹下。
- index.tsx：页面的根组件，用 index.tsx 的原因是引用起来更加方便，可以少写一层引用路径。

4. 开发一个完整的 App，可参考扩展设计思路如下：

```md
.
├── api
├── components
├── packages
├── utils
├── features
├── screen
│ ├── Home
│ │ ├── api
│ │ ├── components
│ │ └── ...
│ └── Follow
└── index.tsx
```

在上面的项目结构中，首页 Home 的页面结构也是 api、components、features、utils、index.tsx 的结构，只不过用 Home 目录包裹起来了，并将其放到了 screen 目录中。一个文件具体放哪儿一层，按照通用程度来划分：

- 页面级别的共享：我会放在 ./screen/Home/api、./screen/Home/components 等目录下；
- 应用级别的共享：一个应用中有多个页面，多个页面之间的共享我会放在 ./api、./components 等目录下；
- 项目级别的共享：有时候项目和项目之间的代码也是会共用的，这部分代码我会放在 packages 目录下，并通过 npm 的方式进行分发。这个思路，我参考的是业内的 monorepo 实践，我们团队内部也在用。

### 页面拆分

1. **UI 设计稿拆成组件，特别是要把组件状态确认好。**

2. 一些 UI 组件在每个 App 上都长得不一样，很难做成多项目通用、业内通用的组件，但自己做项目时直接拿过来改改，还是非常好用的。你看，以前通用组件、通用工具的积累，现在派上用场了吧。

3. 要开发页面，就要先把它拆分成组件。**组件拆分的原则是单一职责原则，一个组件只做一件事。**

**组件的状态根据就近原则进行放置，一般应该先考虑放在该组件上，在考虑父组件**

4. ScrollView

属性说明：

- horizontal 默认为 false，是竖向滚动的，将其设置为 true 时，即可开启横向滚动；
- pagingEnabled 默认为 false，是滚动交互是平滑的，将其设置为 true 时，每滚动一次就翻一页。horizontal 和 pagingEnabled 同时开启的效果类似轮播图；
- onMomentumScrollEnd 是滚动结束事件，当滚动停下来时会触发一次。金刚位的滑动翻页时，有一个长一点的小红条和一个短一点的小灰条，用来表示当前显示的那一屏。使用 onMomentumScrollEnd 就可以控制滑动切换状态了；
- showsHorizontalScrollIndicator 默认为 true，代表默认显示横向滚动条，金刚位的轮播图效果不需要滚动条，因此我准备把它关了。

5. 不能用 RecyclerListView 嵌套 RecyclerListView 来实现混合列表。

RecyclerListView 是继承自 ScrollView 的，同一个方向也就是垂直方向或水平方向，我们尽量只使用一个 ScrollView/RecyclerListView 组件来进行响应。

6. 无限列表的难点：

- 处理首次请求成功、首次请求失败、更多数据加载成功 / 失败、后端没有数据等等情况；
- 考虑性能优化的话，还要做预加载、要管理数据缓存的逻辑，要写很多代码。

## RN 新架构

1. 新架构会默认使用的 Hermes 引擎

2. 新架构的 Fabric 渲染流水线。

### Hermes 引擎

1. Hermes 引擎性能更好。

性能好的核心原因是，相对于 React Native 老架构采用的 JavaScript Core 引擎，Hermes 引擎是专门为移动端打造的。

2. React Native 的老架构默认用的是 JavaScriptCore。JavaScriptCore 也叫做 JSC，它采用的是 JIT 的即时编译方案。

使用 JSC 这类 JIT 即时编译引擎，下发的依旧是 JavaScript 代码。

什么叫 JIT 即时编译呢？

JSC 引擎执行代码的过程是编译一段执行一段，再编译一段再执行一段，这种一边编译一边执行的方式就叫做 JIT 即时编译。

3. Hermes 引擎就在本地先将 JavaScript 编译为字节码，然后再下发字节码。

Hermes 引擎下发的字节码的体积和 JSC 引擎下发的 JavaScript 代码是一样大的，但 Hermes 引擎执行字节码的首屏性能，却是 JSC 引擎执行 JavaScript 首屏性能的 2 倍以上。

### Fabric 渲染器

1. 什么是 Fabric 渲染器？

2. 新架构中已经把 JSBridge 这种消息通知形式改为 JSI（JavaScript Interface）。有了 JSI 后，React Native 中的 JavaScript 就直接调用 C++ 了，就像 node.js 使用 addon 调用 C++ 、Flutter 用 FFI 调用 C++ ，以及 Java 使用 JNI 调用 C++ 一样。

3. fabric 渲染器的特点：

- Fabric 渲染器和新架构的 API 共用了通信层，在 JavaScript 和 C++ 通信这一层的性能也是提升了 3 倍左右。
- **更容易保持跨平台一致性，毕竟 C++ 这块代码都是公用的。** 原来的 Shadow Tree、布局逻辑、视图拍平都是在各个平台单独实现的，现在新架构把这些用 Java/OC 代码实现的逻辑放到了 C++ 层。
- 是拥有优先处理紧急任务的能力。新架构会集成 React18 的 Concurrent 并发模型，有些同学可能对 React18 Concurrent 并发模型有所了解，并发模型可以让优先级更高的渲染任务先执行，优先级低的渲染任务可以中断或批量渲染。

4. React Native 新架构目前还是预览版，这也意味着新架构还没有经过大规模的应用，如果贸然用到业务中去，可能会有风险。

5. React Native 新架构在未来 1~2 年会得到大规模应用。

## 跨端

1. 任何跨平台、跨端软件的共性都是屏蔽底层差异，抽象统一接口，减少开发者的适配成本。

跨平台中的平台二字，通常指的是硬件平台和软件平台，软件平台又包括操作系统平台和软件程序环境。

2. Java、Docker、Chrome、跨端框架都是在操作系统之上的程序环境 ，它们会屏蔽不同操作系统之间的差异性，并向开发者提供了统一的抽象接口，让开发者可以只写一次代码，并运行在多个操作系统之上。

3. 历史的经验告诉我们，无论是硬件平台、操作系统平台、还是程序环境平台，没有哪个平台是一家独大、独霸整个市场的。同一个维度的平台之间，没有赢家通吃的垄断，只有少数几个寡头之间的竞争，寡头竞争的格局产生了跨平台的需求。

4. 从历史和行业视角来看，无论是能源、汽车、金融、软件和现在的互联网行业，都是从原子式的竞争格局走向寡头竞争的格局的。因此，我认为无论未来的商业格局怎么变化，未来的操作系统、未来的程序环境也不会一家独大。

5. 跨端、跨平台的不是伪命题。只要还存在多个寡头并存的平台竞争格局，跨端的需求就会一直存在。认识到这点之后，我对跨端技术未来的担忧也就消失了。

6. DSL 是什么呢？

比如 HTML、JSON 这种非图灵完备的语言就是 DSL，非图灵完备就决定了，它只能解决特定领域的问题，不能解决普适性的问题，复杂业务更是没法处理。

7. 由于苹果公司的政策，只有特定的 JavaScript 程序才能够动态更新，因此能够同时满足跨端、图灵完备和动态更新的特点的语言只有 JavaScript。

8. React Native 的热更新和 React Native SSR 有什么区别呢？

React Native 热更新的本质还是客户端渲染 CSR 方案，首屏渲染速度要比服务端渲染 SSR 方案慢上不少。根据我的性能优化经验，一个复杂的 React Native 应用，采用热更新方案渲染耗时在 2000ms 左右，如果做到极限可能在 700ms 左右。当然，一般达不到极限，因为越是极限，要满足的条件越苛刻，业务的应用范围越小。

9. CSR 渲染的渲染步骤分为 6 步：

- 请求服务端获取最新的 Bundle 资源地址；
- 通过返回的资源地址，下载 Bundle 资源，也就是 JavaScript 代码；
- 初始化 JavaScript 引擎和 Native 模块；
- 执行 JavaScript 代码，生成空页面；
- 与此同时发起业务请求，请求最新的业务数据；
- 业务数据回来后重新渲染，生成最终的页面。

10. SSR 渲染其实是对 CSR 渲染的步骤的重组，整体也是 6 步：

- 并行请求 Tree，和最新的 Bundle 资源地址；
- 初始化 Native 模块，同时开启后台线程并行请求 Bundle 资源
- ；使用 Tree 文件，通过 Fabric 渲染器渲染首屏页面。这里画个重点，此时用户已经可以看到业务页面了；
- 然后再初始化 JavaScript 引擎，开始执行 JavaScript 代码；
- 这一步有个专有名词叫做 Hyration。大致的意思原来通过 Tree 生成的页面是不可交互的“静态”页面，这时需要通过执行 JavaScript，生成一个有交互的“动态”页面，把原来的“静态”页面替换掉；
- 替换后的页面，就是可以交互“动态”页面了。

## 要点

1. 一个认知：重要的不是你学了多少知识，而是你学到了多少知识。

2. 知识本身不重要，要把知识内化成自己的能力才重要。只有以前真正思考过、实践过才能在遇到类似问题时，遇到更好解决方案时，快速学习、决策和解决。

3. 所有的数据、图片用的都是 mockapi.io 的假数据

4. 我们这些搞技术的人，热爱前沿技术是一件好事，但用什么技术得根据自己业务的实际情况来。换句话说，我们既要与时俱进，也要接地气，不能飘着，这样才更容易推动技术落地。

5. 技术要想落地至少分为三步：

- 首先得确定收益，对业务没有收益的事情就不考虑了；
- 其次是确定成本和风险，最关键的控制风险，新技术线上出了大规模故障我们是要担责任的；
