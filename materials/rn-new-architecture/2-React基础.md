# React 基础

## 组件

1. 组件：可组合、可复用的“拆搞”方式

除了组件这种方式外，常见的构建应用方式还有：类似 HTML/CSS/JavaScript 这种的分层架构、基于 MVC 的分层架构。

**基于组件的架构模式，或许是现在重展示、重交互应用的最好选择**

2. React/React Native 选择的是基于组件的架构模式，它有三个好处：

- 组件是内聚的，组件内既有逻辑，又有状态，还有视图，一个组件可以单独完成一件事情，使得 UI 模块复用变得简单；
- 组件之间可以组合，一个页面可以拆分成若各个大组件，大组件也可以拆分成小组件，当某个组件变大变臃肿时也可以进一步地拆分；
- 组件和组件之间的数据流向永远是确定的，永远是从上往下流动的，简单明了。

**组件可组合、可复用的特性，和组件之间单向的数据流模式**， 在现代应用重交互、重展示的情况下，更具有优势。

3. **拆组件要遵循一个原则：单一职责原则。**

每个组件都应该只有一个单一的功能，并且这个组件和其它组件没有相互依赖，**这种思路具有很高的指导价值，** 一个组件的依赖越少，设计得越好。

**注意：为了可读性、可维护性、可测试性**，就要就要减少外部依赖。

### 宿主组件：生产基础视图工厂

1. 要搭建静态页面、就需要基础的视图材料，在 RN 中哪些最基础、不可再拆的视图材料，大都是由 RN 框架提供的**宿主视图**

2. 生产宿主视图的工厂，就是宿主组件(Host Component), 这些**宿主组件通常是 React Native 框架提供的组件，它们和你用 JavaScript 自定义的组件不同，宿主组件是直接由 iOS/Android 原生平台实现的。**

3. 宿主组件的特点：

- 上层是 JavaScript，底层是 native 部分，这两部分是通过 rn 框架联系起来的。

**调用宿主组件时，底层直接渲染的是 native 视图。**

## 样式

1. 大家对 App 的第一印象，就是对页面样式的第一印象。虽说样式设计上是由设计师负责，但最终落地还得靠代码。如何把设计师给的设计稿在不同大小的机型上还原实现，通过验收，是工作中实实在在要面对的考验。

### 组件样式 = 同样样式 + “私有”样式

1. 组件样式是有继承关系的，可以分为三层：

- 通用样式；
- View 组件样式；
- Text/Image 等其它组件的样式；

2. View 组件样式继承了所有通用样式，包括布局 Layout、变换 Transform、阴影 Shadow，除此之外，还有自己的“私有”样式，比如背景颜色 backgroundColor、透明度 opacity、背面可见 backfaceVisibility。另外，Android API 28 以下用的阴影属性 elevation 也是 View 的“私有”样式，为了记忆方便，你也可以将其归类到阴影 Shadow 上。

### Flex：跨平台、高性能、易上手

1. React Native 的布局引擎 Yoga 是 Android、iOS 通用的。

**Flex 布局用的 Yoga 引擎性能很好。**

2. 一个小细节：Android 文字默认会有内边距且基于基线对齐，这会导致文字垂直居中时偏下，**因此垂直居中时，最好把内边距关掉，并把文字放在中线而不是基线上。**

```tsx
<View
  style={{
    alignItems: 'center',
    justifyContent: 'center',
    // 高度确定
    height: 60,
    borderWidth: 1,
  }}
>
  <Text
    style={{
      fontSize: 18,
      // 文字默认内边距，会导致垂直居中偏下
      includeFontPadding: false,
      // 文字默认基于基线对齐，会导致垂直居中偏下
      textAlignVertical: 'center',
    }}
  >
    我是文字1
  </Text>
</View>
```

### StyleSheet：分离、复用、性能好

1. StyleSheet 的好处：

- 元素结构与样式分离，可维护性好；
- 样式对象可以复用，能减少重复代码；
- 样式对象只创建一次，也减少性能的损耗；

## 要点

1. 设置 Text 默认样式：

```ts
if (RN.Platform.OS === 'android') {
  const defaultFontFamily = {
    fontFamily: '',
    // fix: 部分安卓机器上的主题会设置系统字体颜色为白色
    color: '#000',
  };
  const OldTextRender = (RN.Text as any).render;
  (RN.Text as any).render = (props: any, ref: any) => {
    const { style } = props;
    return OldTextRender(
      {
        ...props,
        style: RN.StyleSheet.compose(defaultFontFamily, style),
      },
      ref
    );
  };
}
```

2. RN 很少有机型适配问题，一般遇到了再解决。常见的适配问题是厂商反馈的折叠屏问题。

## state

1. **一个页面也好，一个应用也好，只有把状态设计清楚了，程序才能写的好。**

### 状态初选

1. 看页面那些数据是会变化的，这些会变化的数据都可能是状态，我们先把它们找出来。

2. 程序本身的事件和用户操作都有可能导致页面发生变化，因此我们从这两个方向来进行初选。

### 确定状态

1. 状态初选完成后，不能急着写代码，要先确定一下这些初选状态中那些是真正的状态，把其中无用的状态剔除掉，然后再去写代码。这样代码写得少、写得快，代码逻辑也会更简单一些，也更难出 BUG 一些。

2. 相关技巧：

- 一件事情一个状态

以网络请求的状态为例， 只需要设置一个 state 即可：

```ts
const requestStatus = {
  IDLE: 'IDLE',
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
};
```

- 重复状态不是状态；

- 可计算出来的状态不是状态；

一个状态必须不能通过其他状态、属性或变量直接计算出来，能通过其他值计算出来的状态，都不是状态。

### 状态声明

1. 在定义状态的时候，一定要先考虑好把状态绑定到哪个组件上。我建议你用就近原则来绑定状态，就近原则的意思是哪个组件用上了状态，就优先考虑将状态绑定到该组件上，如果有多个组件使用了同一个状态，则将其绑定到最近的父组件上。这样做能让使用 props 传递状态的次数最少。

2. 对象它是一种复合数据类型，它内部的值是可变的（mutable），但它的引用是不可变了（immutable），你更新了对象的内部值后，它的引用并没有发生变化。
